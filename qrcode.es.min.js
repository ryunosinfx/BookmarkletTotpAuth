/**
 * @fileoverview
 * - Using the 'QRCode for Javascript library'
 * - Fixed dataset of 'QRCode for Javascript library' for support full-spec.
 * - this library has no dependencies.
 *
 * @author davidshimjs
 * @see <a href="http://www.d-project.com/" target="_blank">http://www.d-project.com/</a>
 * @see <a href="http://jeromeetienne.github.com/jquery-qrcode/" target="_blank">http://jeromeetienne.github.com/jquery-qrcode/</a>
 */
//---------------------------------------------------------------------
// QRCode for JavaScript
//
// Copyright (c) 2009 Kazuhiko Arase
//
// URL: http://www.d-project.com/
//
// Licensed under the MIT license:
//   http://www.opensource.org/licenses/mit-license.php
//
// The word "QR Code" is registered trademark of
// DENSO WAVE INCORPORATED
//   http://www.denso-wave.com/qrcode/faqpatent-e.html
//
//---------------------------------------------------------------------
class QR8bitByte {
	constructor(data) {
		const z = this;
		z.mode = QRMode.MODE_8BIT_BYTE;
		z.data = data;
		const parsedData = []; // Added to support UTF-8 Characters
		for (let i = 0, l = data.length; i < l; i++) {
			const b = [],
				c = data.charCodeAt(i);
			if (c > 0x10000) {
				b[0] = 0xf0 | ((c & 0x1c0000) >>> 18);
				b[1] = 0x80 | ((c & 0x3f000) >>> 12);
				b[2] = 0x80 | ((c & 0xfc0) >>> 6);
				b[3] = 0x80 | (c & 0x3f);
			} else if (c > 0x800) {
				b[0] = 0xe0 | ((c & 0xf000) >>> 12);
				b[1] = 0x80 | ((c & 0xfc0) >>> 6);
				b[2] = 0x80 | (c & 0x3f);
			} else if (c > 0x80) {
				b[0] = 0xc0 | ((c & 0x7c0) >>> 6);
				b[1] = 0x80 | (c & 0x3f);
			} else {
				b[0] = c;
			}
			parsedData.push(b);
		}
		z.parsedData = [].concat(parsedData);
		if (z.parsedData.length !== data.length) {
			z.parsedData.unshift(191); // ADD BOM
			z.parsedData.unshift(187);
			z.parsedData.unshift(239);
		}
	}
	getLength() {
		return this.parsedData.length;
	}
	write(buffer) {
		for (let i = 0, l = this.parsedData.length; i < l; i++) buffer.put(this.parsedData[i], 8);
	}
}
class QRCodeModel {
	const;
	constructor(typeNumber, errorCorrectLevel) {
		const z = this;
		z.typeNumber = typeNumber;
		z.errorCorrectLevel = errorCorrectLevel;
		z.modules = null;
		z.moduleCount = 0;
		z.dataCache = null;
		z.dataList = [];
	}
	addData(data) {
		this.dataList.push(new QR8bitByte(data));
		this.dataCache = null;
	}
	isDark(r, c) {
		if (r < 0 || this.moduleCount <= r || c < 0 || this.moduleCount <= c) throw new Error(r + ',' + c);
		return this.modules[r][c];
	}
	getModuleCount() {
		return this.moduleCount;
	}
	make() {
		this.makeImpl(false, this.getBestMaskPattern());
	}
	makeImpl(test, maskPattern) {
		const z = this;
		const n = z.typeNumber * 4 + 17,
			nOM7 = n - 7,
			m = new Array(n);
		z.moduleCount = n;
		z.modules = m;
		for (let rI = 0; rI < n; rI++) {
			const r = new Array(n);
			m[rI] = r;
			for (let cI = 0; cI < n; cI++) r[cI] = null;
		}
		z.setupPositionProbePattern(0, 0);
		z.setupPositionProbePattern(nOM7, 0);
		z.setupPositionProbePattern(0, nOM7);
		z.setupPositionAdjustPattern();
		z.setupTimingPattern();
		z.setupTypeInfo(test, maskPattern);
		if (z.typeNumber >= 7) z.setupTypeNumber(test);
		if (z.dataCache == null) z.dataCache = QRCodeModel.createData(z.typeNumber, z.errorCorrectLevel, z.dataList);
		z.mapData(z.dataCache, maskPattern);
	}
	setupPositionProbePattern(row, col) {
		const n = this.moduleCount,
			m = this.modules;
		for (let r = -1; r <= 7; r++) {
			const rR = row + r;
			if (rR <= -1 || n <= rR) continue;
			for (let c = -1; c <= 7; c++) {
				const cC = col + c;
				if (cC <= -1 || n <= cC) continue;
				m[rR][cC] =
					!!(0 <= r && r <= 6 && (c === 0 || c === 6)) ||
					(0 <= c && c <= 6 && (r === 0 || r === 6)) ||
					(2 <= r && r <= 4 && 2 <= c && c <= 4);
			}
		}
	}
	getBestMaskPattern() {
		let minLP = 0,
			p = 0;
		for (let i = 0; i < 8; i++) {
			this.makeImpl(true, i);
			const lP = QRUtil.getLostPoint(this);
			if (i === 0 || minLP > lP) {
				minLP = lP;
				p = i;
			}
		}
		return p;
	}
	createMovieClip(target_mc, instance_name, depth) {
		const qr_mc = target_mc.createEmptyMovieClip(instance_name, depth),
			cs = 1;
		this.make();
		const m = this.modules;
		for (let rI = 0, rl = m.length; rI < rl; rI++) {
			const y = rI * cs,
				row = m[rI];
			for (let cI = 0, cl = row.length; cI < cl; cI++) {
				const x = cI * cs,
					isDark = row[cI];
				if (isDark) {
					qr_mc.beginFill(0, 100);
					qr_mc.moveTo(x, y);
					qr_mc.lineTo(x + cs, y);
					qr_mc.lineTo(x + cs, y + cs);
					qr_mc.lineTo(x, y + cs);
					qr_mc.endFill();
				}
			}
		}
		return qr_mc;
	}
	setupTimingPattern() {
		const nO = this.moduleCount - 8,
			m = this.modules;
		for (let i = 8; i < nO; i++) {
			const mod = i % 2 === 0,
				r = m[i][6],
				c = m[6][i];
			m[i][6] = r != null ? r : mod;
			m[6][i] = c != null ? c : mod;
		}
	}
	setupPositionAdjustPattern() {
		const pos = QRUtil.getPatternPosition(this.typeNumber),
			pl = pos.length,
			m = this.modules;
		for (let i = 0; i < pl; i++)
			for (let j = 0; j < pl; j++) {
				const rI = pos[i],
					cI = pos[j];
				if (m[rI][cI] != null) continue;
				for (let r = -2; r <= 2; r++) {
					const row = m[rI + r];
					for (let c = -2; c <= 2; c++)
						row[cI + c] = !!(r === -2 || r === 2 || c === -2 || c === 2 || (r === 0 && c === 0));
				}
			}
	}
	setupTypeNumber(test) {
		const bits = QRUtil.getBCHTypeNumber(this.typeNumber),
			n = this.moduleCount,
			m = this.modules;
		for (let i = 0; i < 18; i++) {
			const mod = !test && ((bits >> i) & 1) === 1,
				a = Math.floor(i / 3),
				b = (i % 3) + n - 8 - 3;
			m[a][b] = mod;
			m[b][a] = mod;
		}
	}
	setupTypeInfo(test, maskPattern) {
		const d = (this.errorCorrectLevel << 3) | maskPattern,
			bits = QRUtil.getBCHTypeInfo(d),
			n = this.moduleCount,
			m = this.modules;
		for (let i = 0; i < 15; i++) {
			const mod = !test && ((bits >> i) & 1) === 1;
			if (i < 6) m[i][8] = mod;
			else if (i < 8) m[i + 1][8] = mod;
			else m[n - 15 + i][8] = mod;
			if (i < 8) m[8][n - i - 1] = mod;
			else if (i < 9) m[8][15 - i - 1 + 1] = mod;
			else m[8][15 - i - 1] = mod;
		}
		m[n - 8][8] = !test;
	}
	mapData(data, maskPattern) {
		const n = this.moduleCount,
			m = this.modules,
			dL = data.length;
		let inc = -1,
			rI = n - 1,
			bitI = 7,
			byteI = 0;
		for (let cI = n - 1; cI > 0; cI -= 2) {
			if (cI === 6) cI--;
			while (true) {
				const row = m[rI];
				for (let c = 0; c < 2; c++) {
					const cO = cI - c,
						col = row[cO];
					if (col !== null) continue;
					let isDark = byteI < dL ? ((data[byteI] >>> bitI) & 1) === 1 : false;
					const isMask = QRUtil.getMask(maskPattern, rI, cO);
					if (isMask) isDark = !isDark;
					row[cO] = isDark;
					bitI--;
					if (bitI === -1) {
						byteI++;
						bitI = 7;
					}
				}
				rI += inc;
				if (rI < 0 || n <= rI) {
					rI -= inc;
					inc = -inc;
					break;
				}
			}
		}
	}
	static createData(typeNumber, errorCorrectLevel, dataList) {
		const PAD0 = 0xec,
			PAD1 = 0x11,
			rsBs = QRRSBlock.getRSBlocks(typeNumber, errorCorrectLevel),
			b = new QRBitBuffer();
		for (const data of dataList) {
			b.put(data.mode, 4);
			b.put(data.getLength(), QRUtil.getLengthInBits(data.mode, typeNumber));
			data.write(b);
		}
		let tCC = 0;
		for (const rsBlock of rsBs) tCC += rsBlock.dataCount;
		const tDBC = tCC * 8,
			bitL = b.getLengthInBits();
		if (bitL > tDBC) throw new Error('code length overflow. (' + bitL + '>' + tDBC + ')');
		if (bitL + 4 <= tDBC) b.put(0, 4);
		while (b.getLengthInBits() % 8 !== 0) b.putBit(false);
		while (true) {
			if (b.getLengthInBits() >= tDBC) break;
			b.put(PAD0, 8);
			if (b.getLengthInBits() >= tDBC) break;
			b.put(PAD1, 8);
		}
		return QRCodeModel.createBytes(b, rsBs);
	}
	static createBytes(buffer, rsBlocks) {
		let offset = 0,
			maxDC = 0,
			maxEC = 0;
		const bitB = buffer.buffer,
			len = rsBlocks.length,
			dc = new Array(len),
			ec = new Array(len);
		let tCC = 0;
		for (let r = 0; r < len; r++) {
			const rsB = rsBlocks[r],
				dC = rsB.dataCount,
				eC = rsB.totalCount - dC,
				dDR = new Array(dC);
			maxDC = Math.max(maxDC, dC);
			maxEC = Math.max(maxEC, eC);
			for (let i = 0; i < dC; i++) dDR[i] = 0xff & bitB[i + offset];
			dc[r] = dDR;
			offset += dC;
			const rsPoly = QRUtil.getErrorCorrectPolynomial(eC),
				ecLen = rsPoly.getLength() - 1,
				rawPoly = new QRPolynomial(dDR, ecLen),
				modPoly = rawPoly.mod(rsPoly),
				modLen = modPoly.getLength(),
				offsetLen = modLen - ecLen,
				eDR = new Array(ecLen);
			for (let i = 0; i < ecLen; i++) {
				const modI = i + offsetLen;
				eDR[i] = modI >= 0 ? modPoly.get(modI) : 0;
			}
			ec[r] = eDR;
			tCC += rsB.totalCount;
		}
		const d = new Array(tCC);
		let idx = 0;
		for (let i = 0; i < maxDC; i++)
			for (let r = 0; r < len; r++) {
				const dDR = dc[r];
				if (i < dDR.length) d[idx++] = dDR[i];
			}
		for (let i = 0; i < maxEC; i++)
			for (let r = 0; r < len; r++) {
				const eDR = ec[r];
				if (i < eDR.length) d[idx++] = eDR[i];
			}
		return d;
	}
}
const QRMode = { MODE_NUMBER: 1 << 0, MODE_ALPHA_NUM: 1 << 1, MODE_8BIT_BYTE: 1 << 2, MODE_KANJI: 1 << 3 };
const QRErrorCorrectLevel = { L: 1, M: 0, Q: 3, H: 2 };
const QRErrorCorrectLevelOffsetMap = {};
const QRMaskPattern = {
	PATTERN000: 0,
	PATTERN001: 1,
	PATTERN010: 2,
	PATTERN011: 3,
	PATTERN100: 4,
	PATTERN101: 5,
	PATTERN110: 6,
	PATTERN111: 7,
};
const QRUtil = {
	PATTERN_POSITION_TABLE: [
		[],
		[6, 18],
		[6, 22],
		[6, 26],
		[6, 30],
		[6, 34],
		[6, 22, 38],
		[6, 24, 42],
		[6, 26, 46],
		[6, 28, 50],
		[6, 30, 54],
		[6, 32, 58],
		[6, 34, 62],
		[6, 26, 46, 66],
		[6, 26, 48, 70],
		[6, 26, 50, 74],
		[6, 30, 54, 78],
		[6, 30, 56, 82],
		[6, 30, 58, 86],
		[6, 34, 62, 90],
		[6, 28, 50, 72, 94],
		[6, 26, 50, 74, 98],
		[6, 30, 54, 78, 102],
		[6, 28, 54, 80, 106],
		[6, 32, 58, 84, 110],
		[6, 30, 58, 86, 114],
		[6, 34, 62, 90, 118],
		[6, 26, 50, 74, 98, 122],
		[6, 30, 54, 78, 102, 126],
		[6, 26, 52, 78, 104, 130],
		[6, 30, 56, 82, 108, 134],
		[6, 34, 60, 86, 112, 138],
		[6, 30, 58, 86, 114, 142],
		[6, 34, 62, 90, 118, 146],
		[6, 30, 54, 78, 102, 126, 150],
		[6, 24, 50, 76, 102, 128, 154],
		[6, 28, 54, 80, 106, 132, 158],
		[6, 32, 58, 84, 110, 136, 162],
		[6, 26, 54, 82, 110, 138, 166],
		[6, 30, 58, 86, 114, 142, 170],
	],
	G15: (1 << 10) | (1 << 8) | (1 << 5) | (1 << 4) | (1 << 2) | (1 << 1) | (1 << 0),
	G18: (1 << 12) | (1 << 11) | (1 << 10) | (1 << 9) | (1 << 8) | (1 << 5) | (1 << 2) | (1 << 0),
	G15_MASK: (1 << 14) | (1 << 12) | (1 << 10) | (1 << 4) | (1 << 1),
	getBCHTypeInfo(data) {
		let d = data << 10;
		const Q = QRUtil;
		while (Q.getBCHDigit(d) - Q.getBCHDigit(Q.G15) >= 0) d ^= Q.G15 << (Q.getBCHDigit(d) - Q.getBCHDigit(Q.G15));
		return ((data << 10) | d) ^ Q.G15_MASK;
	},
	getBCHTypeNumber(data) {
		let d = data << 12;
		const Q = QRUtil;
		while (Q.getBCHDigit(d) - Q.getBCHDigit(Q.G18) >= 0) d ^= Q.G18 << (Q.getBCHDigit(d) - Q.getBCHDigit(Q.G18));
		return (data << 12) | d;
	},
	getBCHDigit(data) {
		let digit = 0;
		while (data !== 0) {
			digit++;
			data >>>= 1;
		}
		return digit;
	},
	getPatternPosition(typeNumber) {
		return QRUtil.PATTERN_POSITION_TABLE[typeNumber - 1];
	},
	getMask(maskP, i, j) {
		const Q = QRMaskPattern;
		switch (maskP) {
			case Q.PATTERN000:
				return (i + j) % 2 === 0;
			case Q.PATTERN001:
				return i % 2 === 0;
			case Q.PATTERN010:
				return j % 3 === 0;
			case Q.PATTERN011:
				return (i + j) % 3 === 0;
			case Q.PATTERN100:
				return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 === 0;
			case Q.PATTERN101:
				return ((i * j) % 2) + ((i * j) % 3) === 0;
			case Q.PATTERN110:
				return (((i * j) % 2) + ((i * j) % 3)) % 2 === 0;
			case Q.PATTERN111:
				return (((i * j) % 3) + ((i + j) % 2)) % 2 === 0;
			default:
				throw new Error('bad maskPattern:' + maskP);
		}
	},
	getErrorCorrectPolynomial(errorCorrectLength) {
		let a = new QRPolynomial([1], 0);
		for (let i = 0; i < errorCorrectLength; i++) a = a.multiply(new QRPolynomial([1, QRMath.gexp(i)], 0));
		return a;
	},
	getLengthInBits(mode, type) {
		if (1 <= type && type < 10) {
			switch (mode) {
				case QRMode.MODE_NUMBER:
					return 10;
				case QRMode.MODE_ALPHA_NUM:
					return 9;
				case QRMode.MODE_8BIT_BYTE:
					return 8;
				case QRMode.MODE_KANJI:
					return 8;
				default:
					throw new Error('mode:' + mode);
			}
		} else if (type < 27) {
			switch (mode) {
				case QRMode.MODE_NUMBER:
					return 12;
				case QRMode.MODE_ALPHA_NUM:
					return 11;
				case QRMode.MODE_8BIT_BYTE:
					return 16;
				case QRMode.MODE_KANJI:
					return 10;
				default:
					throw new Error('mode:' + mode);
			}
		} else if (type < 41) {
			switch (mode) {
				case QRMode.MODE_NUMBER:
					return 14;
				case QRMode.MODE_ALPHA_NUM:
					return 13;
				case QRMode.MODE_8BIT_BYTE:
					return 16;
				case QRMode.MODE_KANJI:
					return 12;
				default:
					throw new Error('mode:' + mode);
			}
		} else throw new Error('type:' + type);
	},
	getLostPoint(qrC) {
		const n = qrC.getModuleCount();
		let lP = 0;
		for (let row = 0; row < n; row++)
			for (let col = 0; col < n; col++) {
				let sC = 0;
				const isDark = qrC.isDark(row, col);
				for (let r = -1; r <= 1; r++) {
					const rR = row + r;
					if (rR < 0 || n <= rR) continue;
					for (let c = -1; c <= 1; c++) {
						const cC = col + c;
						if (cC < 0 || n <= cC) continue;
						if (r === 0 && c === 0) continue;
						if (isDark === qrC.isDark(rR, cC)) sC++;
					}
				}
				if (sC > 5) lP += 3 + sC - 5;
			}
		for (let r = 0; r < n - 1; r++) {
			const r1 = r + 1;
			for (let c = 0; c < n - 1; c++) {
				let cnt = 0;
				const c1 = c + 1;
				if (qrC.isDark(r, c)) cnt++;
				if (qrC.isDark(r1, c)) cnt++;
				if (qrC.isDark(r, c1)) cnt++;
				if (qrC.isDark(r1, c1)) cnt++;
				if (cnt === 0 || cnt === 4) lP += 3;
			}
		}
		for (let r = 0; r < n; r++)
			for (let c = 0; c < n - 6; c++)
				if (
					qrC.isDark(r, c) &&
					!qrC.isDark(r, c + 1) &&
					qrC.isDark(r, c + 2) &&
					qrC.isDark(r, c + 3) &&
					qrC.isDark(r, c + 4) &&
					!qrC.isDark(r, c + 5) &&
					qrC.isDark(r, c + 6)
				)
					lP += 40;
		for (let c = 0; c < n; c++)
			for (let r = 0; r < n - 6; r++)
				if (
					qrC.isDark(r, c) &&
					!qrC.isDark(r + 1, c) &&
					qrC.isDark(r + 2, c) &&
					qrC.isDark(r + 3, c) &&
					qrC.isDark(r + 4, c) &&
					!qrC.isDark(r + 5, c) &&
					qrC.isDark(r + 6, c)
				)
					lP += 40;
		let dC = 0;
		for (let col = 0; col < n; col++) for (let row = 0; row < n; row++) if (qrC.isDark(row, col)) dC++;
		const ratio = Math.abs((100 * dC) / n / n - 50) / 5;
		lP += ratio * 10;
		return lP;
	},
};
class QRMath {
	static glog(n) {
		if (n < 1) throw new Error('glog(' + n + ')');
		return QRMath.LOG_TABLE[n];
	}
	static gexp(n) {
		while (n < 0) n += 255;
		while (n >= 256) n -= 255;
		return QRMath.EXP_TABLE[n];
	}
	static init() {
		const expT = new Array(256),
			logT = new Array(256);
		for (let i = 0; i < 8; i++) expT[i] = 1 << i;
		for (let i = 8; i < 256; i++) expT[i] = expT[i - 4] ^ expT[i - 5] ^ expT[i - 6] ^ expT[i - 8];
		for (let i = 0; i < 255; i++) logT[expT[i]] = i;
		QRMath.EXP_TABLE = expT;
		QRMath.LOG_TABLE = logT;
	}
}
QRMath.init();
class QRPolynomial {
	constructor(num, shift) {
		const nL = num.length;
		if (nL === undefined) throw new Error(nL + '/' + shift);
		let offset = 0;
		while (offset < nL && num[offset] === 0) offset++;
		const nLO = nL - offset,
			nums = new Array(nLO + shift);
		for (let i = 0; i < nLO; i++) nums[i] = num[i + offset];
		this.num = nums;
	}
	get(index) {
		return this.num[index];
	}
	getLength() {
		return this.num.length;
	}
	multiply(e) {
		const n = this.num,
			nL = n.length,
			eNum = e.num,
			eLen = eNum.length,
			numResult = new Array(nL + eLen - 1);
		for (let i = 0; i < nL; i++) {
			const numGlog = QRMath.glog(n[i]);
			for (let j = 0; j < eLen; j++) {
				const eNumGlog = QRMath.glog(eNum[j]);
				numResult[i + j] ^= QRMath.gexp(numGlog + eNumGlog);
			}
		}
		return new QRPolynomial(numResult, 0);
	}
	mod(e) {
		const n = this.num,
			nL = n.length,
			eNum = e.num,
			eLen = eNum.length;
		if (nL - eLen < 0) return this;
		const ratio = QRMath.glog(n[0]) - QRMath.glog(eNum[0]),
			numResult = new Array(nL);
		for (let i = 0; i < nL; i++) numResult[i] = n[i];
		for (let i = 0; i < eLen; i++) numResult[i] ^= QRMath.gexp(QRMath.glog(eNum[i]) + ratio);
		return new QRPolynomial(numResult, 0).mod(e);
	}
}
class QRRSBlock {
	constructor(tC, dC) {
		this.totalCount = tC;
		this.dataCount = dC;
	}
	static getRSBlocks(typeNumber, errorCorrectLevel) {
		const rsB = QRRSBlock.getRsBlockTable(typeNumber, errorCorrectLevel);
		if (rsB === undefined)
			throw new Error('bad rs block @ typeNumber:' + typeNumber + '/errorCorrectLevel:' + errorCorrectLevel);
		const l = rsB.length / 3,
			rsBs = [];
		for (let i = 0; i < l; i++) {
			const idx = i * 3,
				c = rsB[idx + 0],
				tC = rsB[idx + 1],
				dC = rsB[idx + 2];
			for (let j = 0; j < c; j++) rsBs.push(new QRRSBlock(tC, dC));
		}
		return rsBs;
	}
	static getRsBlockTable(typeNumber, errorCorrectLevel) {
		const bECL = (typeNumber - 1) * 4;
		const Q = QRErrorCorrectLevel;
		const T = QRRSBlock.RS_BLOCK_TABLE;
		switch (errorCorrectLevel) {
			case Q.L:
				return T[bECL + 0];
			case Q.M:
				return T[bECL + 1];
			case Q.Q:
				return T[bECL + 2];
			case Q.H:
				return T[bECL + 3];
			default:
				return undefined;
		}
	}
}
QRRSBlock.RS_BLOCK_TABLE = [
	[1, 26, 19],
	[1, 26, 16],
	[1, 26, 13],
	[1, 26, 9],
	[1, 44, 34],
	[1, 44, 28],
	[1, 44, 22],
	[1, 44, 16],
	[1, 70, 55],
	[1, 70, 44],
	[2, 35, 17],
	[2, 35, 13],
	[1, 100, 80],
	[2, 50, 32],
	[2, 50, 24],
	[4, 25, 9],
	[1, 134, 108],
	[2, 67, 43],
	[2, 33, 15, 2, 34, 16],
	[2, 33, 11, 2, 34, 12],
	[2, 86, 68],
	[4, 43, 27],
	[4, 43, 19],
	[4, 43, 15],
	[2, 98, 78],
	[4, 49, 31],
	[2, 32, 14, 4, 33, 15],
	[4, 39, 13, 1, 40, 14],
	[2, 121, 97],
	[2, 60, 38, 2, 61, 39],
	[4, 40, 18, 2, 41, 19],
	[4, 40, 14, 2, 41, 15],
	[2, 146, 116],
	[3, 58, 36, 2, 59, 37],
	[4, 36, 16, 4, 37, 17],
	[4, 36, 12, 4, 37, 13],
	[2, 86, 68, 2, 87, 69],
	[4, 69, 43, 1, 70, 44],
	[6, 43, 19, 2, 44, 20],
	[6, 43, 15, 2, 44, 16],
	[4, 101, 81],
	[1, 80, 50, 4, 81, 51],
	[4, 50, 22, 4, 51, 23],
	[3, 36, 12, 8, 37, 13],
	[2, 116, 92, 2, 117, 93],
	[6, 58, 36, 2, 59, 37],
	[4, 46, 20, 6, 47, 21],
	[7, 42, 14, 4, 43, 15],
	[4, 133, 107],
	[8, 59, 37, 1, 60, 38],
	[8, 44, 20, 4, 45, 21],
	[12, 33, 11, 4, 34, 12],
	[3, 145, 115, 1, 146, 116],
	[4, 64, 40, 5, 65, 41],
	[11, 36, 16, 5, 37, 17],
	[11, 36, 12, 5, 37, 13],
	[5, 109, 87, 1, 110, 88],
	[5, 65, 41, 5, 66, 42],
	[5, 54, 24, 7, 55, 25],
	[11, 36, 12],
	[5, 122, 98, 1, 123, 99],
	[7, 73, 45, 3, 74, 46],
	[15, 43, 19, 2, 44, 20],
	[3, 45, 15, 13, 46, 16],
	[1, 135, 107, 5, 136, 108],
	[10, 74, 46, 1, 75, 47],
	[1, 50, 22, 15, 51, 23],
	[2, 42, 14, 17, 43, 15],
	[5, 150, 120, 1, 151, 121],
	[9, 69, 43, 4, 70, 44],
	[17, 50, 22, 1, 51, 23],
	[2, 42, 14, 19, 43, 15],
	[3, 141, 113, 4, 142, 114],
	[3, 70, 44, 11, 71, 45],
	[17, 47, 21, 4, 48, 22],
	[9, 39, 13, 16, 40, 14],
	[3, 135, 107, 5, 136, 108],
	[3, 67, 41, 13, 68, 42],
	[15, 54, 24, 5, 55, 25],
	[15, 43, 15, 10, 44, 16],
	[4, 144, 116, 4, 145, 117],
	[17, 68, 42],
	[17, 50, 22, 6, 51, 23],
	[19, 46, 16, 6, 47, 17],
	[2, 139, 111, 7, 140, 112],
	[17, 74, 46],
	[7, 54, 24, 16, 55, 25],
	[34, 37, 13],
	[4, 151, 121, 5, 152, 122],
	[4, 75, 47, 14, 76, 48],
	[11, 54, 24, 14, 55, 25],
	[16, 45, 15, 14, 46, 16],
	[6, 147, 117, 4, 148, 118],
	[6, 73, 45, 14, 74, 46],
	[11, 54, 24, 16, 55, 25],
	[30, 46, 16, 2, 47, 17],
	[8, 132, 106, 4, 133, 107],
	[8, 75, 47, 13, 76, 48],
	[7, 54, 24, 22, 55, 25],
	[22, 45, 15, 13, 46, 16],
	[10, 142, 114, 2, 143, 115],
	[19, 74, 46, 4, 75, 47],
	[28, 50, 22, 6, 51, 23],
	[33, 46, 16, 4, 47, 17],
	[8, 152, 122, 4, 153, 123],
	[22, 73, 45, 3, 74, 46],
	[8, 53, 23, 26, 54, 24],
	[12, 45, 15, 28, 46, 16],
	[3, 147, 117, 10, 148, 118],
	[3, 73, 45, 23, 74, 46],
	[4, 54, 24, 31, 55, 25],
	[11, 45, 15, 31, 46, 16],
	[7, 146, 116, 7, 147, 117],
	[21, 73, 45, 7, 74, 46],
	[1, 53, 23, 37, 54, 24],
	[19, 45, 15, 26, 46, 16],
	[5, 145, 115, 10, 146, 116],
	[19, 75, 47, 10, 76, 48],
	[15, 54, 24, 25, 55, 25],
	[23, 45, 15, 25, 46, 16],
	[13, 145, 115, 3, 146, 116],
	[2, 74, 46, 29, 75, 47],
	[42, 54, 24, 1, 55, 25],
	[23, 45, 15, 28, 46, 16],
	[17, 145, 115],
	[10, 74, 46, 23, 75, 47],
	[10, 54, 24, 35, 55, 25],
	[19, 45, 15, 35, 46, 16],
	[17, 145, 115, 1, 146, 116],
	[14, 74, 46, 21, 75, 47],
	[29, 54, 24, 19, 55, 25],
	[11, 45, 15, 46, 46, 16],
	[13, 145, 115, 6, 146, 116],
	[14, 74, 46, 23, 75, 47],
	[44, 54, 24, 7, 55, 25],
	[59, 46, 16, 1, 47, 17],
	[12, 151, 121, 7, 152, 122],
	[12, 75, 47, 26, 76, 48],
	[39, 54, 24, 14, 55, 25],
	[22, 45, 15, 41, 46, 16],
	[6, 151, 121, 14, 152, 122],
	[6, 75, 47, 34, 76, 48],
	[46, 54, 24, 10, 55, 25],
	[2, 45, 15, 64, 46, 16],
	[17, 152, 122, 4, 153, 123],
	[29, 74, 46, 14, 75, 47],
	[49, 54, 24, 10, 55, 25],
	[24, 45, 15, 46, 46, 16],
	[4, 152, 122, 18, 153, 123],
	[13, 74, 46, 32, 75, 47],
	[48, 54, 24, 14, 55, 25],
	[42, 45, 15, 32, 46, 16],
	[20, 147, 117, 4, 148, 118],
	[40, 75, 47, 7, 76, 48],
	[43, 54, 24, 22, 55, 25],
	[10, 45, 15, 67, 46, 16],
	[19, 148, 118, 6, 149, 119],
	[18, 75, 47, 31, 76, 48],
	[34, 54, 24, 34, 55, 25],
	[20, 45, 15, 61, 46, 16],
];
const QRCodeLimitLength = [
	[17, 14, 11, 7],
	[32, 26, 20, 14],
	[53, 42, 32, 24],
	[78, 62, 46, 34],
	[106, 84, 60, 44],
	[134, 106, 74, 58],
	[154, 122, 86, 64],
	[192, 152, 108, 84],
	[230, 180, 130, 98],
	[271, 213, 151, 119],
	[321, 251, 177, 137],
	[367, 287, 203, 155],
	[425, 331, 241, 177],
	[458, 362, 258, 194],
	[520, 412, 292, 220],
	[586, 450, 322, 250],
	[644, 504, 364, 280],
	[718, 560, 394, 310],
	[792, 624, 442, 338],
	[858, 666, 482, 382],
	[929, 711, 509, 403],
	[1003, 779, 565, 439],
	[1091, 857, 611, 461],
	[1171, 911, 661, 511],
	[1273, 997, 715, 535],
	[1367, 1059, 751, 593],
	[1465, 1125, 805, 625],
	[1528, 1190, 868, 658],
	[1628, 1264, 908, 698],
	[1732, 1370, 982, 742],
	[1840, 1452, 1030, 790],
	[1952, 1538, 1112, 842],
	[2068, 1628, 1168, 898],
	[2188, 1722, 1228, 958],
	[2303, 1809, 1283, 983],
	[2431, 1911, 1351, 1051],
	[2563, 1989, 1423, 1093],
	[2699, 2099, 1499, 1139],
	[2809, 2213, 1579, 1219],
	[2953, 2331, 1663, 1273],
];
class QRBitBuffer {
	constructor() {
		this.buffer = [];
		this.length = 0;
	}
	get(idx) {
		const bufI = Math.floor(idx / 8);
		return ((this.buffer[bufI] >>> (7 - (idx % 8))) & 1) === 1;
	}
	put(num, length) {
		for (let i = 0; i < length; i++) this.putBit(((num >>> (length - i - 1)) & 1) === 1);
	}
	getLengthInBits() {
		return this.length;
	}
	putBit(bit) {
		const bufI = Math.floor(this.length / 8);
		if (this.buffer.length <= bufI) this.buffer.push(0);
		if (bit) this.buffer[bufI] |= 0x80 >>> this.length % 8;
		this.length++;
	}
}
class SvgDrawer {
	constructor(elm, htmlOption) {
		this.elm = elm;
		this.htmlOption = htmlOption;
	}
	draw(qrCodeData) {
		const z = this;
		const opt = z.htmlOption,
			elm = z.elm,
			nC = qrCodeData.getModuleCount();
		elm.style.width = opt.width + 'px';
		elm.style.height = opt.height + 'px';
		const nWidth = Math.floor(opt.width / nC),
			nHeight = Math.floor(opt.height / nC);
		z.clear();
		const attrs = {
			viewBox: '0 0 ' + nC + ' ' + nC,
			width: '100%',
			height: '100%',
			fill: opt.colorLight,
		};
		const svg = z.makeSVG('svg', attrs);
		svg.setAttributeNS('http://www.w3.org/2000/xmlns/', 'xmlns:xlink', 'http://www.w3.org/1999/xlink');
		elm.appendChild(svg);
		svg.appendChild(z.makeSVG('rect', { fill: opt.colorLight, width: '100%', height: '100%' }));
		svg.appendChild(z.makeSVG('rect', { fill: opt.colorDark, width: '1', height: '1', id: 'template' }));
		for (let rI = 0; rI < nC; rI++)
			for (let cI = 0; cI < nC; cI++)
				if (qrCodeData.isDark(rI, cI)) {
					const c = z.makeSVG('use', { x: cI + '', y: rI + '' });
					c.setAttributeNS('http://www.w3.org/1999/xlink', 'href', '#template');
					svg.appendChild(c);
				}
	}
	makeSVG(t, a) {
		const e = document.createElementNS('http://www.w3.org/2000/svg', t);
		for (const [k, v] of Object.entries(a)) if (v) e.setAttribute(k, v);
		return e;
	}
	clear() {
		while (this.elm.hasChildNodes()) this.elm.removeChild(this.elm.lastChild);
	}
}
class HtmlDrawer {
	constructor(elm, htmlOption) {
		this.elm = elm;
		this.htmlOption = htmlOption;
	}
	/**
	 * Draw the QRCode
	 *
	 * @param {QRCode} qrCodeData
	 */
	draw(qrCodeData) {
		const opt = this.htmlOption,
			elm = this.elm,
			nCount = qrCodeData.getModuleCount(),
			nWidth = Math.floor(opt.width / nCount),
			nHeight = Math.floor(opt.height / nCount),
			tE = document.createElement('table');
		tE.style.borderWidth = 0;
		tE.style.borderCollapse = 'collapse';
		for (let row = 0; row < nCount; row++) {
			const trE = document.createElement('tr');
			for (let col = 0; col < nCount; col++) {
				const color = qrCodeData.isDark(row, col) ? opt.colorDark : opt.colorLight,
					tE = document.createElement('td');
				tE.style.borderWidth = 0;
				tE.style.borderCollapse = 'collapse';
				tE.style.padding = 0;
				tE.style.margin = 0;
				tE.style.width = nWidth;
				tE.style.height = nHeight;
				tE.style.backgroundColor = color;
				trE.append(tE);
			}
			tE.append(trE);
		}
		elm.append(tE);
		const elT = elm.childNodes[0], // Fix the margin values as real size.
			nLeftMT = (opt.width - elT.offsetWidth) / 2,
			nTopMT = (opt.height - elT.offsetHeight) / 2;
		if (nLeftMT > 0 && nTopMT > 0) elT.style.margin = nTopMT + 'px ' + nLeftMT + 'px';
	}
	/**
	 * Clear the QRCode
	 */
	clear() {
		while (this.elm.hasChildNodes()) this.elm.removeChild(this.elm.lastChild);
	}
}
class CanvasDrawer {
	/**
	 * Drawing QRCode by using canvas
	 *
	 * @constructor
	 * @param {HTMLElement} elm
	 * @param {Object} htmlOption QRCode Options
	 */
	constructor(elm, htmlOption) {
		const z = this;
		z.opt = htmlOption;
		z.cElm = document.createElement('canvas');
		z.cElm.width = htmlOption.width;
		z.cElm.height = htmlOption.height;
		z.cElm.style.position = 'absolute';
		z.cElm.style.top = htmlOption.height * -1;
		elm.appendChild(z.cElm);
		z.elm = elm;
		z.ctx = z.cElm.getContext('2d');
		z.iElm = document.createElement('img');
		z.iElm.alt = 'Scan me!';
		z.iElm.style.display = 'none';
		z.elm.appendChild(this.iElm);
	}
	/**
	 * Draw the QRCode
	 *
	 * @param {QRCode} qrCodeData
	 */
	draw(qrCodeData) {
		const z = this;
		const opt = z.opt;
		z.cElm.width = opt.width;
		z.cElm.height = opt.height;
		const imgElm = z.iElm,
			ctx = z.ctx,
			nCount = qrCodeData.getModuleCount(),
			nWidth = opt.width / nCount,
			nHeight = opt.height / nCount,
			nRoundedWidth = Math.round(nWidth),
			nRoundedHeight = Math.round(nHeight);
		imgElm.style.display = 'none';
		z.clear();
		for (let rI = 0; rI < nCount; rI++) {
			for (let cI = 0; cI < nCount; cI++) {
				const isDark = qrCodeData.isDark(rI, cI),
					nLeft = cI * nWidth,
					nTop = rI * nHeight;
				ctx.strokeStyle = isDark ? opt.colorDark : opt.colorLight;
				ctx.lineWidth = 1;
				ctx.fillStyle = isDark ? opt.colorDark : opt.colorLight;
				ctx.fillRect(nLeft, nTop, nWidth, nHeight);
				ctx.strokeRect(Math.floor(nLeft) + 0.5, Math.floor(nTop) + 0.5, nRoundedWidth, nRoundedHeight);
				ctx.strokeRect(Math.ceil(nLeft) - 0.5, Math.ceil(nTop) - 0.5, nRoundedWidth, nRoundedHeight);
			}
		}
		z.iElm.src = z.cElm.toDataURL('image/png');
		z.iElm.style.display = 'block';
		z.cElm.style.display = 'none';
	}
	/**
	 * Clear the QRCode
	 */
	clear() {
		this.ctx.clearRect(0, 0, this.cElm.width, this.cElm.height);
		this.iElm.style.display = 'none';
	}
}
/**
 * @class QRCode
 * @constructor
 * @example
 * new QRCode(document.getElementById("test"), "http://jindo.dev.naver.com/collie");
 *
 * @example
 * var qrCodeData = new QRCode("test", {
 *    text : "http://naver.com",
 *    width : 128,
 *    height : 128
 * });
 *
 * qrCodeData.clear(); // Clear the QRCode.
 * qrCodeData.makeCode("http://map.naver.com"); // Re-create the QRCode.
 *
 * @param {HTMLElement|String} el target element or 'id' attribute of element.
 * @param {Object|String} vOption
 * @param {String} vOption.text QRCode link data
 * @param {Number} [vOption.width=256]
 * @param {Number} [vOption.height=256]
 * @param {String} [vOption.colorDark="#000000"]
 * @param {String} [vOption.colorLight="#ffffff"]
 * @param {QRErrorCorrectLevel} [vOption.correctLevel=QRErrorCorrectLevel.H] [L|M|Q|H]
 */
export class QRCode {
	constructor(elm, vOption = {}) {
		const z = this;
		z.opt = {
			width: 256,
			height: 256,
			colorDark: '#000000',
			colorLight: '#ffffff',
			correctLevel: QRErrorCorrectLevel.H,
		};
		if (typeof vOption === 'string')
			vOption = {
				text: vOption,
			};
		if (vOption) for (let i in vOption) z.opt[i] = vOption[i]; // Overwrites options
		const e = typeof elm === 'string' ? document.getElementById(elm) : elm,
			DrawingClass = z.opt.useSVG ? SvgDrawer : z.opt.useHtml ? HtmlDrawer : CanvasDrawer;
		z.elm = e;
		z.drawer = new DrawingClass(e, z.opt);
		if (z.opt.text) z.makeCode(z.opt.text);
	}
	/**
	 * Make the QRCode
	 *
	 * @param {String} sText link data
	 */
	makeCode(sText) {
		const z = this;
		const cL = z.opt.correctLevel,
			qrCD = new QRCodeModel(z._getTypeNumber(sText, cL), cL);
		qrCD.addData(sText);
		qrCD.make();
		z.elm.title = sText;
		z.drawer.draw(qrCD);
		z.makeImage();
	}
	/**
	 * Get the type by string length
	 *
	 * @private
	 * @param {String} sText
	 * @param {Number} nCorrectLevel
	 * @return {Number} type
	 */
	_getTypeNumber(sText, nCorrectLevel) {
		let nType = 1;
		const l = QRCodeLimitLength.length,
			length = this._getUTF8Length(sText);
		for (let i = 0; i <= l; i++) {
			let nL = 0;
			const lL = QRCodeLimitLength[i];
			switch (nCorrectLevel) {
				case QRErrorCorrectLevel.L:
					nL = lL[0];
					break;
				case QRErrorCorrectLevel.M:
					nL = lL[1];
					break;
				case QRErrorCorrectLevel.Q:
					nL = lL[2];
					break;
				case QRErrorCorrectLevel.H:
					nL = lL[3];
					break;
			}
			if (length <= nL) break;
			else nType++;
		}
		if (nType > l) throw new Error('Too long data');
		return nType;
	}
	_getUTF8Length(sText) {
		const rT = encodeURI(sText)
			.toString()
			.replace(/\%[0-9a-fA-F]{2}/g, 'a');
		return rT.length + (rT.length !== sText ? 3 : 0);
	}
	/**
	 * Make the Image from Canvas element
	 * - It occurs automatically
	 * - Android below 3 doesn't support Data-URI spec.
	 *
	 * @private
	 */
	makeImage() {
		if (typeof this.drawer.makeImage === 'function') this.drawer.makeImage();
	}
	/**
	 * reset size of the QRCode
	 * @param {Number} [vOption.width=256]
	 * @param {Number} [vOption.height=256]
	 */
	setSize(width = 256, height = 256) {
		this.opt.width = width;
		this.opt.height = height;
	}
	/**
	 * reset color of the QRCode
	 * @param {String} [vOption.colorDark="#000000"]
	 * @param {String} [vOption.colorLight="#ffffff"]
	 */
	setColor(colorDark = '#000000', colorLight = '#ffffff') {
		this.opt.colorDark = colorDark;
		this.opt.colorLight = colorLight;
	}
	/**
	 * reset recorrectLeve of the QRCode
	 * @param {QRErrorCorrectLevel} [vOption.correctLevel=QRErrorCorrectLevel.H] [L|M|Q|H]
	 */
	setCorrectLevel(cL = QRErrorCorrectLevel.H) {
		const Q = QRErrorCorrectLevel;
		if (typeof cL === 'string') {
			if (cL === 'H') this.opt.correctLevel = Q.H;
			else if (cL === 'Q') this.opt.correctLevel = Q.Q;
			else if (cL === 'M') this.opt.correctLevel = Q.M;
			else if (cL === 'L') this.opt.correctLevel = Q.L;
		} else this.opt.correctLevel = cL;
	}
	/**
	 * Clear the QRCode
	 */
	clear() {
		this.drawer.clear();
	}
}
export class HtmlQRCode extends QRCode {
	constructor(
		elm,
		text = 'HtmlQRCode',
		width = 256,
		height = 256,
		colorDark = '#000000',
		colorLight = '#ffffff',
		correctLevel = QRErrorCorrectLevel.H
	) {
		super(elm, { text, width, height, colorDark, colorLight, correctLevel, useHtml: true });
	}
}
export class SvgQRCode extends QRCode {
	constructor(
		elm,
		text = 'SvgQRCode',
		width = 256,
		height = 256,
		colorDark = '#000000',
		colorLight = '#ffffff',
		correctLevel = QRErrorCorrectLevel.H
	) {
		super(elm, { text, width, height, colorDark, colorLight, correctLevel, useSVG: true });
	}
}
export class CanvasQRCode extends QRCode {
	constructor(
		elm,
		text = 'CanvasQRCode',
		width = 256,
		height = 256,
		colorDark = '#000000',
		colorLight = '#ffffff',
		correctLevel = QRErrorCorrectLevel.H
	) {
		super(elm, { text, width, height, colorDark, colorLight, correctLevel });
	}
}
